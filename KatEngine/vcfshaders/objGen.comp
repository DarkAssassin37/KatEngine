#version 430

struct AttribData
{
      vec4 v;
      vec4 c;
};

layout(std140, binding = 0) buffer destBuffer
{
      AttribData data[];

} outBuffer;

layout(std140, binding = 1) buffer destBuffer2
{
      uint data[];

} outBuffer2;


uniform sampler2D heightMap;


layout (local_size_x = 8, local_size_y = 8) in;


void main()
{

      ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);


      uint gWidth = gl_WorkGroupSize.x * gl_NumWorkGroups.x;
      uint gHeight = gl_WorkGroupSize.y * gl_NumWorkGroups.y;
	  vec2 size = vec2(gWidth,gHeight);
	  vec2 pos = vec2(storePos) / size;
      
	  uint gSize = gWidth * gHeight;

      uint offset = storePos.y * gWidth + storePos.x;
	  uint offsetNextRow = (storePos.y + 1) * gWidth + storePos.x;

      // Calculate an angle for the current thread

      float alpha = 2.0 * 3.14159265359 * (float(offset) / float(gSize));



      outBuffer.data[offset].v.xz = pos.xy * 2.0 - 1.0;// cos(alpha) * 0.7;
      outBuffer.data[offset].v.y =  texture(heightMap, pos).r * 1.0;
      outBuffer.data[offset].v.w = 1.0;

      // Assign colour for the vertex
      outBuffer.data[offset].c.b = 1.0;//storePos.x / float(gWidth);
      outBuffer.data[offset].c.g = 1.0;
      outBuffer.data[offset].c.r = 1.0;
	  outBuffer.data[offset].c.w = 1.0;

	  outBuffer.data[offset].c = texture(heightMap, pos);



	  if(storePos.y < gHeight && storePos.x < gWidth)
	  {
		  outBuffer2.data[offset] = 0;
		  outBuffer2.data[offsetNextRow + 0] = 0;
		  outBuffer2.data[offsetNextRow + 1] = 0;

		  outBuffer2.data[offset] = 0;
		  outBuffer2.data[offsetNextRow + 0] = 0;
		  outBuffer2.data[offsetNextRow + 1] = 0;

		  outBuffer2.data[offset] = 0;
		  outBuffer2.data[offsetNextRow + 1] = 0;
		  outBuffer2.data[offset + 0] = 0;
	  }
}
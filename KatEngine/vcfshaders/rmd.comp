#version 430 core
#define deltaN 0.001
#define delta 1.0
layout(binding = 0, rgba32f) uniform image2D framebuffer;

// The camera specification
layout(location = 0) uniform vec3 eye;
layout(location = 1) uniform vec3 ray00;
layout(location = 2) uniform vec3 ray01;
layout(location = 3) uniform vec3 ray10;
layout(location = 4) uniform vec3 ray11;

float sdInfiniplane(vec3 p, vec3 o, vec3 n)
{
	vec3 dv = p - o; 
	float dist = dot(dv, n);
	return dist;
}

float sdCeby(vec3 p, float s)
{
	vec3 d = abs(p)-s;
	return max(max(d.x, d.y), d.z);
}

float sdSphere( vec3 p, float s )
{
  return length(p)-s;
}

float scDist(vec3 p)
{	
	float minDist = sdCeby(p, 1.0);
	minDist = min(minDist, sdInfiniplane(p, vec3(0,-0.5,0), vec3(0,1,0)));
	return minDist;
}

vec3 normal(vec3 p){
	vec3 res = vec3(
		scDist(vec3(p.x + deltaN, p.y, p.z)) - scDist(vec3(p.x - deltaN, p.y, p.z)),
		scDist(vec3(p.x, p.y + deltaN, p.z)) - scDist(vec3(p.x, p.y - deltaN, p.z)),
		scDist(vec3(p.x, p.y, p.z + deltaN)) - scDist(vec3(p.x, p.y, p.z - deltaN))
	);
	return normalize(res);
}

vec4 trace(vec3 origin, vec3 dir) {

  vec3 cp = origin;
  float cdist = 0.0;
  for(int i = 0; i < 10; i++)
  {
      cdist = scDist(cp);
	  vec3 norm = normal(cp);
	  float illum = dot(norm, vec3(1.0,1.0,0.2));
      if(cdist < delta)
          return vec4(abs(norm) * clamp(illum, 0.2, 1.0), 0.0);

      cp = cp + cdist * dir;
  }

  return vec4(0.08, 0.0, 0.08, 1.0);
}


layout (local_size_x = 8, local_size_y = 8) in;

void main(void) {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x, size.y);
  vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
  dir = normalize(dir);

  vec4 color = trace(eye, dir);
  imageStore(framebuffer, pix, color);
}

#version 430 core
#define deltaN 0.1
#define delta 0.1
layout(binding = 0, rgba32f) uniform image2D framebuffer;

layout(location = 0) uniform vec3 eye;
layout(location = 1) uniform vec3 ray00;
layout(location = 2) uniform vec3 ray01;
layout(location = 3) uniform vec3 ray10;
layout(location = 4) uniform vec3 ray11;

float sdInfiniplane(vec3 p, vec3 o, vec3 n)
{
	vec3 dv = p - o; 
	float dist = dot(dv, n);
	return dist;
}

float sdCeby(vec3 p, vec3 o, float s)
{
	//vec3 d = abs(p-o) - s;
	//return max(max(d.x, d.y), d.z);
	vec3 d = abs(p-o) - s;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdSphere( vec3 p, vec3 o, float s )
{
  return length(p-o)-s;
}

float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}

float unionSDF(float distA, float distB) {
    return min(distA, distB);
}

float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

//scDist(vec3 p) must have the same objects and parameters as scDist(vec3 p, out vec3 color)
float scDist(vec3 p)
{	
	float minDist = differenceSDF(
						sdCeby(p, vec3(0,0.5,0), 1.0),
						sdSphere(p, vec3(0,0.5,0), 1.3)
					);

	minDist = min(minDist, sdInfiniplane(p, vec3(0,-1.0,0), vec3(0,1,0)));

	minDist = min(minDist, sdSphere(p, vec3(0, 3.0,0), 1.0));

	return minDist;
}

//objects with different colors implemented here
float scDist(vec3 p, out vec3 color)
{	
	float lastminDist  = 1000.0;
	vec3 finalColor = vec3(1.0,0.0,0.0);

	//object
	float minDist = intersectSDF(
						sdCeby(p, vec3(0,0.5,0), 1.0),
						sdSphere(p, vec3(0,0.5,0), 1.3)
					);
	//if its ditance is used update the final color with its color
	if(minDist < lastminDist){
		finalColor = vec3(1.0,1.0,1.0) * 0.8;
		lastminDist = minDist;
	}

	minDist = min(minDist, sdInfiniplane(p, vec3(0,-0.5,0), vec3(0,1,0)));
	if(minDist < lastminDist){
		finalColor = vec3(1, 0.509, 0.019);
		lastminDist = minDist;
	}

	minDist = min(minDist, sdSphere(p, vec3(0, 3.0,0), 1.0));
	if(minDist < lastminDist){
		finalColor = vec3(10, 0, 0);
		lastminDist = minDist;
	}

	color = finalColor;
	return minDist;
}

vec3 normal(vec3 p){
	vec3 res = vec3(
		scDist(vec3(p.x + deltaN, p.y, p.z)) - scDist(vec3(p.x - deltaN, p.y, p.z)),
		scDist(vec3(p.x, p.y + deltaN, p.z)) - scDist(vec3(p.x, p.y - deltaN, p.z)),
		scDist(vec3(p.x, p.y, p.z + deltaN)) - scDist(vec3(p.x, p.y, p.z - deltaN))
	);

	return normalize(res);
}



vec4 trace(vec3 origin, vec3 dir) {

  //return vec4(0.88, 0.0, 0.08, 1.0);
  vec3 cp = origin;//current point
  float cdist = 0.0;//current distance from current point to closest surface
  float tdist = 0.0;//total distance travelledby the ray
  
  float lastHit = 0.0;//last hit distance
  vec3 finalColor = vec3(0.08, 0.0, 0.08);
  vec3 currColor;//current object(closest one) color
  float first = 1.0;
  float dDist = 0;//distance covered by taking the last step
  float collisions = 0.0;//number of collisions so far

  for(int i = 0; i < 1000 && tdist < 200.0 ; i++)
  {
      cdist = scDist(cp, currColor);
	  vec3 norm = normal(cp);

	  if(currColor.x > 1.0)//special coloring mode for normals
		currColor = (norm + 1.0) * 0.5;

	  float illum = max(1.0, dot(norm, vec3(1.0,1.0,0.2)));

      if(cdist < delta)//close enough to an object consider it a collision
	  {
		  
		  //return vec4((norm + 1.0) * 0.5 , 1.0); //normals

		  collisions += 1.0;


		  //return vec4(currColor / tdist , 1.0);
		  dDist = tdist - lastHit;
		  dDist = dDist * dDist;
		  lastHit = tdist;

		  //float blend = max(1.0, 1.0 / dDist);
		 // blend = 1.0;
		  //finalColor = first * currColor;// + (1.0-first) * (currColor * blend + (1-blend) * finalColor); //abs(norm) * clamp(illum, 0.2, 1.0) * multiplier + (1-multiplier) * finalColor;
		  
		  dir = normalize(reflect(dir, norm));


		  /*if(first < 1.0) 
			return vec4(finalColor, 1.0);
		  else
			finalColor *= illum;
		
			first = min(0.0, first);
		  */
		  
		  if(collisions > 1.5f)//0.5 = first hit, 1.5 = second hit, etc.
			//break;
			//return vec4(vec3(1.0,1.0,1.0) * (1.0 - dDist * 0.01), 1.0);//hit distance, 
			//return vec4(currColor, 1.0);//hit color
			return vec4((norm + 1.0) * 0.5 , 1.0);//hit normal
			//return vec4((dir + 1.0) * 0.5 , 1.0);//hit new direction
	  }

	  tdist += cdist;
      cp = cp + cdist * dir;
  }

  //return vec4(1.0,0.0,0.0, 1.0);

 //return vec4(collisions*vec3(0.1,0.2,0.1),1.0);

  return vec4(finalColor, 1.0);
}


layout (local_size_x = 8, local_size_y = 8) in;

void main(void) {
  ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(framebuffer);
  if (pix.x >= size.x || pix.y >= size.y) {
    return;
  }
  vec2 pos = vec2(pix) / vec2(size.x, size.y);
  vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
  dir = normalize(dir);

  vec4 color = trace(eye, dir);
  imageStore(framebuffer, pix, color);
}
